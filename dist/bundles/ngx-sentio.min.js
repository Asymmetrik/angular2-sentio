/*! @asymmetrik/ngx-sentio - 5.0.0-alpha.1 - Copyright Asymmetrik, Ltd. 2007-2017 - All Rights Reserved. + */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("@angular/core"),require("@asymmetrik/sentio"),require("d3-selection"),require("rxjs")):"function"==typeof define&&define.amd?define(["exports","@angular/core","@asymmetrik/sentio","d3-selection","rxjs"],e):e(t.ngxSentio={},t.ng.core,t.sentio,t.d3,t.Rx)}(this,function(t,e,r,i,s){"use strict";/**
 * Wrapper for chart info
 */
var n=/** @class */function(){/**
     * Creates the chart, binds it to the dom element.
     * This doesn't do any DOM manipulation yet.
     * @param el
     * @param chart
     */
function t(t,e,r){this.chartElement=i.select(t.nativeElement),this.chart=e,this.chartReady=r}/**
     * Initializes the chart, creating its DOM structure
     */
return t.prototype.initialize=function(){this.chart.init(this.chartElement),this.chartReady.emit(this.chart)},t}(),a=/** @class */function(){function t(t,e,r,n){void 0===e&&(e=!0),void 0===r&&(r=200),void 0===n&&(n=100);var a=this;this.enabled=e,this.chartElement=i.select(t.nativeElement),this.chartElement.style("display","block"),
// Create a hot observable for resize events
this.resizeSource=s.Observable.create(function(t){a.resizeObserver=t}).publish().refCount().filter(function(){return a.enabled}),null!=r&&(this.resizeSource=this.resizeSource.debounceTime(r)),null!=n&&(this.resizeSource=this.resizeSource.sample(s.Observable.interval(n))),this.resizeSource=this.resizeSource.map(function(){return a.getSize()})}/**
     * Determines the numerical dimension given a string representation
     * Assumes the string is in the form 'NNNNNpx', more specifically
     * an arbitrarily long sequence of digits terminated by 'px'
     *
     * @param dimStr A string representation of the pixel size
     * @returns {number} the numerical representation of the pixel size
     */
/**
     * Gets the size context info for the current element
     * Two relevant things are computed:
     *
     * element size:
     *   Determines the chart size if the user has tried to specify the size on the directive
     *   - directive element size
     *
     * parent size:
     *   Used when resizing to fit parent. The size returned should be the size that the element should be.
     *   - directive parent size minus padding, margin, and border
     *
     *
     * @returns {ResizeDimension}
     */
return t.parseFloat=function(t,e){var r=parseFloat(t);return isNaN(r)?e:r},t.getPixelDimension=function(t){var e;return null!=t&&""!==t&&(null==(e=parseFloat(t.substring(0,t.length-2)))||isNaN(e))&&(e=void 0),e},t.prototype.getComputedElementSize=function(e){
// Get the raw body element
var r=document.body,i=r.style.overflow;r.style.overflow="hidden";var s=getComputedStyle(e),n=t.parseFloat(s.width,0),a=t.parseFloat(s.height,0);
// Reapply the old overflow setting
return r.style.overflow=i,{width:n,height:a}},t.prototype.getSize=function(){return{element:this.getComputedElementSize(this.chartElement.node()),parent:this.getComputedElementSize(this.chartElement.node().parentElement)}},t.prototype.destroy=function(){this.resizeObserver.complete()},t}(),h=/** @class */function(){function t(t){
// Chart Ready event
this.chartReady=new e.EventEmitter,
// Create the chart
this.chartWrapper=new n(t,r.chartDonut(),this.chartReady),
// Set up the resizer
this.resizeUtil=new a(t,this.resizeEnabled)}/**
     * For the donut chart, we pin the height to the width
     * to keep the aspect ratio correct
     */
/** @nocollapse */
return t.prototype.setChartDimensions=function(t,e){void 0===e&&(e=!1);var r;
// If resize is enabled, we want to resize to parent
this.resizeEnabled?r=t.parent:e&&(r=t.element),null!=r&&null!=r.width&&this.chartWrapper.chart.width()!==r.width&&
// pin the height to the width
this.chartWrapper.chart.width(r.width).height(r.width).resize()},t.prototype.onResize=function(t){this.resizeUtil.resizeObserver.next(t)},t.prototype.ngOnInit=function(){var t=this;
// Initialize the chart
this.chartWrapper.initialize(),
// Set up the resize callback
this.resizeUtil.resizeSource.subscribe(function(){
// Do the resize operation
t.setChartDimensions(t.resizeUtil.getSize()),t.chartWrapper.chart.redraw()}),
// Set the initial size of the chart
this.setChartDimensions(this.resizeUtil.getSize(),!0),this.chartWrapper.chart.redraw()},t.prototype.ngOnDestroy=function(){this.resizeUtil.destroy()},t.prototype.ngOnChanges=function(t){var e=!1,r=!1;t.data&&(this.chartWrapper.chart.data(this.data),r=r||!t.data.isFirstChange()),t.duration&&this.chartWrapper.chart.duration(this.duration),t.colorScale&&(this.chartWrapper.chart.colorScale(this.colorScale),r=r||!t.colorScale.isFirstChange()),t.resizeEnabled&&(this.resizeUtil.enabled=this.resizeEnabled,e=e||this.resizeEnabled&&!t.resizeEnabled.isFirstChange(),r=r||e),
// Only redraw once if necessary
e&&this.chartWrapper.chart.resize(),r&&this.chartWrapper.chart.redraw()},t.decorators=[{type:e.Directive,args:[{selector:"sentioDonutChart"}]}],t.ctorParameters=function(){return[{type:e.ElementRef}]},t.propDecorators={data:[{type:e.Input,args:["sentioData"]}],colorScale:[{type:e.Input,args:["sentioColorScale"]}],resizeEnabled:[{type:e.Input,args:["sentioResize"]}],duration:[{type:e.Input,args:["sentioDuration"]}],chartReady:[{type:e.Output,args:["sentioChartReady"]}],onResize:[{type:e.HostListener,args:["window:resize",["$event"]]}]},t}(),o=/** @class */function(){/**
     * Creates the chart, binds it to the dom element.
     * This doesn't do any DOM manipulation yet.
     * @param el
     * @param chart
     */
function t(t){/**
         * Did the state of the brush change?
         */
this.didBrushChange=function(t,e){
// Deep compare the brush
return t!==e&&(null==t||null==e||t[0]!==e[0]||t[1]!==e[1])},this.chartWrapper=t}return t.prototype.setChartDimensions=function(t,e,r,i){void 0===i&&(i=!1);var s,n,a=!1;
// If resize is enabled, we want to resize to parent
e?s=t.parent.width:i&&(s=t.element.width),
// If resize is enabled, we want to resize to parent
r?n=t.parent.height:i&&(n=t.element.height),null!=s&&this.chartWrapper.chart.width()!==s&&(this.chartWrapper.chart.width(s),a=!0),null!=n&&this.chartWrapper.chart.height()!==n&&(this.chartWrapper.chart.height(n),a=!0),a&&this.chartWrapper.chart.resize()},t.prototype.onChanges=function(t){var e=!1;return t.data&&(this.chartWrapper.chart.data(t.data.currentValue),e=e||!t.data.isFirstChange()),t.series&&(this.chartWrapper.chart.series(t.series.currentValue),e=e||!t.series.isFirstChange()),t.markers&&(this.chartWrapper.chart.markers(t.markers.currentValue),e=e||!t.markers.isFirstChange()),t.yExtent&&(this.chartWrapper.chart.yExtent().overrideValue(t.yExtent.currentValue),e=e||!t.yExtent.isFirstChange()),t.xExtent&&(this.chartWrapper.chart.xExtent().overrideValue(t.xExtent.currentValue),e=e||!t.xExtent.isFirstChange()),t.showGrid&&(this.chartWrapper.chart.showGrid(t.showGrid.currentValue),e=e||!t.showGrid.isFirstChange()),t.showXGrid&&(this.chartWrapper.chart.showXGrid(t.showXGrid.currentValue),e=e||!t.showXGrid.isFirstChange()),t.showYGrid&&(this.chartWrapper.chart.showYGrid(t.showYGrid.currentValue),e=e||!t.showYGrid.isFirstChange()),t.pointEvents&&(this.chartWrapper.chart.pointEvents(t.pointEvents.currentValue),e=e||!t.showYGrid.isFirstChange()),t.brushEnabled&&(this.chartWrapper.chart.brush(t.brushEnabled.currentValue),e=e||!t.brushEnabled.isFirstChange()),t.brushState&&!t.brushState.isFirstChange()&&this.didBrushChange(t.brushState.currentValue,t.brushState.previousValue)&&(this.chartWrapper.chart.setBrush(t.brushState.currentValue),e=!0),{resize:!1,redraw:e}},t}(),p=/** @class */function(){function t(t){
// Chart Ready event
this.chartReady=new e.EventEmitter,this.brushChange=new e.EventEmitter,
// Extent State
this.extentChange=new e.EventEmitter,
// Create the chart
this.chartWrapper=new n(t,r.chartAutoBrushTimeline(),this.chartReady),
// Set up the resizer
this.resizeUtil=new a(t,this.resizeHeight||this.resizeWidth),this.timelineUtil=new o(this.chartWrapper)}/** @nocollapse */
return t.prototype.onResize=function(t){this.resizeUtil.resizeObserver.next(t)},t.prototype.ngOnInit=function(){var t=this;
// Initialize the chart
this.chartWrapper.initialize(),
// register for the auto-brush events
this.chartWrapper.chart.dispatch().on("brushChange.internal",function(e){t.timelineUtil.didBrushChange(e,t.brushState)&&setTimeout(function(){t.brushChange.emit(e)})}).on("extentChange.internal",function(e){return t.extentChange.emit(e)}),
// Set up the resize callback
this.resizeUtil.resizeSource.subscribe(function(){
// Do the resize operation
t.timelineUtil.setChartDimensions(t.resizeUtil.getSize(),t.resizeWidth,t.resizeHeight),t.chartWrapper.chart.redraw()}),
// Set the initial size of the chart
this.timelineUtil.setChartDimensions(this.resizeUtil.getSize(),this.resizeWidth,this.resizeHeight,!0),this.chartWrapper.chart.redraw(),
// Set the brush (if it exists)
null!=this.brushState&&this.chartWrapper.chart.setBrush(this.brushState)},t.prototype.ngOnDestroy=function(){this.resizeUtil.destroy()},t.prototype.ngOnChanges=function(t){var e=this.timelineUtil.onChanges(t);
// Only redraw once if necessary
e.resize&&this.chartWrapper.chart.resize(),e.redraw&&this.chartWrapper.chart.redraw()},t.decorators=[{type:e.Directive,args:[{selector:"sentioAutoBrushTimeline"}]}],t.ctorParameters=function(){return[{type:e.ElementRef}]},t.propDecorators={data:[{type:e.Input,args:["sentioData"]}],series:[{type:e.Input,args:["sentioSeries"]}],yExtent:[{type:e.Input,args:["sentioYExtent"]}],resizeWidth:[{type:e.Input,args:["sentioResizeWidth"]}],resizeHeight:[{type:e.Input,args:["sentioResizeHeight"]}],edgeTrigger:[{type:e.Input,args:["sentioEdgeTrigger"]}],zoomInTrigger:[{type:e.Input,args:["sentioZoomInTrigger"]}],zoomOutTrigger:[{type:e.Input,args:["sentioZoomOutTrigger"]}],zoomTarget:[{type:e.Input,args:["sentiozoomTarget"]}],maxExtent:[{type:e.Input,args:["sentioMaxExtent"]}],minExtent:[{type:e.Input,args:["sentioMinExtent"]}],minBrush:[{type:e.Input,args:["sentioMinBrush"]}],chartReady:[{type:e.Output,args:["sentioChartReady"]}],brushState:[{type:e.Input,args:["sentioBrush"]}],brushChange:[{type:e.Output,args:["sentioBrushChange"]}],extentChange:[{type:e.Output,args:["sentioExtentChange"]}],onResize:[{type:e.HostListener,args:["window:resize",["$event"]]}]},t}(),u=/** @class */function(){function t(t){
// Chart Ready event
this.chartReady=new e.EventEmitter,
// Interaction events
this.brush=new e.EventEmitter,this.pointMouseover=new e.EventEmitter,this.pointMouseout=new e.EventEmitter,this.pointClick=new e.EventEmitter,this.markerMouseover=new e.EventEmitter,this.markerMouseout=new e.EventEmitter,this.markerClick=new e.EventEmitter,
// Create the chart
this.chartWrapper=new n(t,r.chartTimeline(),this.chartReady),
// Set up the resizer
this.resizeUtil=new a(t,this.resizeHeight||this.resizeWidth),this.timelineUtil=new o(this.chartWrapper)}/** @nocollapse */
return t.prototype.onResize=function(t){this.resizeUtil.resizeObserver.next(t)},t.prototype.ngOnInit=function(){var t=this;
// Initialize the chart
this.chartWrapper.initialize(),
// register for the point events
this.chartWrapper.chart.dispatch().on("pointClick.internal",function(e){return t.pointClick.emit(e)}).on("pointMouseover.internal",function(e){return t.pointMouseover.emit(e)}).on("pointMouseout.internal",function(e){return t.pointMouseout.emit(e)}),
// register for the marker events
this.chartWrapper.chart.dispatch().on("markerClick.internal",function(e){return t.markerClick.emit(e)}).on("markerMouseover.internal",function(e){return t.markerMouseover.emit(e)}).on("markerMouseout.internal",function(e){return t.markerMouseout.emit(e)}),
// register for the brush end event
this.chartWrapper.chart.dispatch().on("brushEnd.internal",function(e){
// If the brush actually changed, emit the event
t.timelineUtil.didBrushChange(e,t.brushState)&&setTimeout(function(){t.brush.emit(e)})}),
// Set up the resize callback
this.resizeUtil.resizeSource.subscribe(function(){
// Do the resize operation
t.timelineUtil.setChartDimensions(t.resizeUtil.getSize(),t.resizeWidth,t.resizeHeight),t.chartWrapper.chart.redraw()}),
// Set the initial size of the chart
this.timelineUtil.setChartDimensions(this.resizeUtil.getSize(),this.resizeWidth,this.resizeHeight,!0),this.chartWrapper.chart.redraw(),
// Set the brush (if it exists)
null!=this.brushState&&this.chartWrapper.chart.setBrush(this.brushState)},t.prototype.ngOnDestroy=function(){this.resizeUtil.destroy()},t.prototype.ngOnChanges=function(t){var e=this.timelineUtil.onChanges(t);
// Only redraw once if necessary
e.resize&&this.chartWrapper.chart.resize(),e.redraw&&this.chartWrapper.chart.redraw()},t.decorators=[{type:e.Directive,args:[{selector:"sentioTimeline"}]}],t.ctorParameters=function(){return[{type:e.ElementRef}]},t.propDecorators={data:[{type:e.Input,args:["sentioData"]}],series:[{type:e.Input,args:["sentioSeries"]}],markers:[{type:e.Input,args:["sentioMarkers"]}],yExtent:[{type:e.Input,args:["sentioYExtent"]}],xExtent:[{type:e.Input,args:["sentioXExtent"]}],showGrid:[{type:e.Input,args:["sentioShowGrid"]}],showXGrid:[{type:e.Input,args:["sentioShowXGrid"]}],showYGrid:[{type:e.Input,args:["sentioShowYGrid"]}],pointEvents:[{type:e.Input,args:["sentioPointEvents"]}],resizeWidth:[{type:e.Input,args:["sentioResizeWidth"]}],resizeHeight:[{type:e.Input,args:["sentioResizeHeight"]}],chartReady:[{type:e.Output,args:["sentioChartReady"]}],brushEnabled:[{type:e.Input,args:["sentioBrushEnabled"]}],brushState:[{type:e.Input,args:["sentioBrush"]}],brush:[{type:e.Output,args:["sentioBrushChange"]}],pointMouseover:[{type:e.Output,args:["sentioPointMouseover"]}],pointMouseout:[{type:e.Output,args:["sentioPointMouseout"]}],pointClick:[{type:e.Output,args:["sentioPointClick"]}],markerMouseover:[{type:e.Output,args:["sentioMarkerMouseover"]}],markerMouseout:[{type:e.Output,args:["sentioMarkerMouseout"]}],markerClick:[{type:e.Output,args:["sentioMarkerClick"]}],onResize:[{type:e.HostListener,args:["window:resize",["$event"]]}]},t}(),c=/** @class */function(){function t(){}
// Set the autoBrush timeline brush to the new value
// Set the timeline extent to the new value
/** @nocollapse */
return t.prototype.setBrush=function(t){this.autoBrush.setBrush(t),this.autoBrush.redraw()},t.prototype.ngOnInit=function(){var t=this;this.timeline=this.timelineDirective.chartWrapper.chart,this.autoBrush=this.autoBrushDirective.chartWrapper.chart,
// Default config
this.timeline.margin({top:16,right:8,bottom:24,left:32}).showGrid(!0).pointEvents("values").brush(!1),this.timeline.yExtent().overrideValue([0,void 0]),this.timeline.xAxis().ticks(6),this.timeline.xGridAxis().ticks(6),this.autoBrush.margin({top:2,right:8,bottom:2,left:32}),this.autoBrush.yExtent().overrideValue([0,void 0]),
// Auto Brush events
this.autoBrush.dispatch().on("brushChange.internalDynamicTimeline",function(e){t.setTimelineExtent(e)})},t.prototype.setTimelineExtent=function(t){this.timeline.xExtent().overrideValue(t),this.timeline.redraw()},t.decorators=[{type:e.Directive,args:[{selector:"[sentioDynamicTimeline]"}]}],t.ctorParameters=function(){return[]},t.propDecorators={timelineDirective:[{type:e.ContentChild,args:[u]}],autoBrushDirective:[{type:e.ContentChild,args:[p]}]},t}(),l=/** @class */function(){function t(t){
// Chart Ready event
this.chartReady=new e.EventEmitter,
// Create the chart
this.chartWrapper=new n(t,r.chartMatrix(),this.chartReady)}/** @nocollapse */
return t.prototype.ngOnInit=function(){
// Initialize the chart
this.chartWrapper.initialize(),this.chartWrapper.chart.redraw()},t.prototype.ngOnDestroy=function(){},t.prototype.ngOnChanges=function(t){var e=!1;t.data&&(this.chartWrapper.chart.data(this.data),e=e||!t.data.isFirstChange()),t.series&&(this.chartWrapper.chart.series(this.series),e=e||!t.series.isFirstChange()),t.duration&&this.chartWrapper.chart.duration(this.duration),
// Only redraw once if possible
e&&this.chartWrapper.chart.redraw()},t.decorators=[{type:e.Directive,args:[{selector:"sentioMatrixChart"}]}],t.ctorParameters=function(){return[{type:e.ElementRef}]},t.propDecorators={data:[{type:e.Input,args:["sentioData"]}],series:[{type:e.Input,args:["sentioSeries"]}],duration:[{type:e.Input,args:["sentioDuration"]}],chartReady:[{type:e.Output,args:["sentioChartReady"]}]},t}(),d=/** @class */function(){function t(t){
// Chart Ready event
this.chartReady=new e.EventEmitter,
// Interaction events
this.markerMouseover=new e.EventEmitter,this.markerMouseout=new e.EventEmitter,this.markerClick=new e.EventEmitter,
// Create the chart
this.chartWrapper=new n(t,r.chartRealtimeTimeline(),this.chartReady),
// Set up the resizer
this.resizeUtil=new a(t,this.resizeHeight||this.resizeWidth),this.timelineUtil=new o(this.chartWrapper)}/** @nocollapse */
return t.prototype.onResize=function(t){this.resizeUtil.resizeObserver.next(t)},t.prototype.ngOnInit=function(){var t=this;
// Initialize the chart
this.chartWrapper.initialize(),
// register for the marker events
this.chartWrapper.chart.dispatch().on("markerClick",function(e){t.markerClick.emit(e)}),this.chartWrapper.chart.dispatch().on("markerMouseover",function(e){t.markerMouseover.emit(e)}),this.chartWrapper.chart.dispatch().on("markerMouseout",function(e){t.markerMouseout.emit(e)}),
// Set up the resize callback
this.resizeUtil.resizeSource.subscribe(function(){
// Do the resize operation
t.timelineUtil.setChartDimensions(t.resizeUtil.getSize(),t.resizeWidth,t.resizeHeight),t.chartWrapper.chart.redraw()}),
// Set the initial size of the chart
this.timelineUtil.setChartDimensions(this.resizeUtil.getSize(),this.resizeWidth,this.resizeHeight,!0),this.chartWrapper.chart.redraw()},t.prototype.ngOnDestroy=function(){this.resizeUtil.destroy()},t.prototype.ngOnChanges=function(t){var e=this.timelineUtil.onChanges(t);t.fps&&this.chartWrapper.chart.fps(this.fps),t.delay&&(this.chartWrapper.chart.delay(this.delay),e.redraw=e.redraw||!t.delay.isFirstChange()),t.interval&&(this.chartWrapper.chart.interval(this.interval),e.redraw=e.redraw||!t.interval.isFirstChange()),
// Only redraw once if necessary
e.resize&&this.chartWrapper.chart.resize(),e.redraw&&this.chartWrapper.chart.redraw()},t.decorators=[{type:e.Directive,args:[{selector:"sentioRealtimeTimeline"}]}],t.ctorParameters=function(){return[{type:e.ElementRef}]},t.propDecorators={data:[{type:e.Input,args:["sentioData"]}],series:[{type:e.Input,args:["sentioSeries"]}],markers:[{type:e.Input,args:["sentioMarkers"]}],yExtent:[{type:e.Input,args:["sentioYExtent"]}],xExtent:[{type:e.Input,args:["sentioXExtent"]}],showGrid:[{type:e.Input,args:["sentioShowGrid"]}],showXGrid:[{type:e.Input,args:["sentioShowXGrid"]}],showYGrid:[{type:e.Input,args:["sentioShowYGrid"]}],delay:[{type:e.Input,args:["sentioDelay"]}],fps:[{type:e.Input,args:["sentioFps"]}],interval:[{type:e.Input,args:["sentioInterval"]}],resizeWidth:[{type:e.Input,args:["sentioResizeWidth"]}],resizeHeight:[{type:e.Input,args:["sentioResizeHeight"]}],chartReady:[{type:e.Output,args:["sentioChartReady"]}],markerMouseover:[{type:e.Output,args:["sentioMarkerMouseover"]}],markerMouseout:[{type:e.Output,args:["sentioMarkerMouseout"]}],markerClick:[{type:e.Output,args:["sentioMarkerClick"]}],onResize:[{type:e.HostListener,args:["window:resize",["$event"]]}]},t}(),g=/** @class */function(){function t(t){
// Chart Ready event
this.chartReady=new e.EventEmitter,
// Create the chart
this.chartWrapper=new n(t,r.chartVerticalBars(),this.chartReady),
// Set up the resizer
this.resizeUtil=new a(t,this.resizeEnabled)}/**
     * For The vertical bar chart, we just resize width
     */
/** @nocollapse */
return t.prototype.setChartDimensions=function(t,e){void 0===e&&(e=!1);var r;
// If resize is enabled, we want to resize to parent
this.resizeEnabled?r=t.parent:e&&(r=t.element),null!=r&&null!=r.width&&this.chartWrapper.chart.width()!==r.width&&
// pin the height to the width
this.chartWrapper.chart.width(r.width).resize()},t.prototype.onResize=function(t){this.resizeUtil.resizeObserver.next(t)},t.prototype.ngOnInit=function(){var t=this;
// Initialize the chart
this.chartWrapper.initialize(),
// Set up the resize callback
this.resizeUtil.resizeSource.subscribe(function(){
// Do the resize operation
t.setChartDimensions(t.resizeUtil.getSize()),t.chartWrapper.chart.redraw()}),
// Set the initial size of the chart
this.setChartDimensions(this.resizeUtil.getSize(),!0),this.chartWrapper.chart.redraw()},t.prototype.ngOnDestroy=function(){this.resizeUtil.destroy()},t.prototype.ngOnChanges=function(t){var e=!1,r=!1;t.data&&(this.chartWrapper.chart.data(this.data),r=r||!t.data.isFirstChange()),t.widthExtent&&(this.chartWrapper.chart.widthExtent().overrideValue(this.widthExtent),r=r||!t.widthExtent.isFirstChange()),t.resizeEnabled&&(this.resizeUtil.enabled=this.resizeEnabled,e=e||this.resizeEnabled&&!t.resizeEnabled.isFirstChange(),r=r||e),
// Only redraw once if necessary
e&&this.chartWrapper.chart.resize(),r&&this.chartWrapper.chart.redraw()},t.decorators=[{type:e.Directive,args:[{selector:"sentioVerticalBarChart"}]}],t.ctorParameters=function(){return[{type:e.ElementRef}]},t.propDecorators={data:[{type:e.Input,args:["sentioData"]}],widthExtent:[{type:e.Input,args:["sentioWidthExtent"]}],resizeEnabled:[{type:e.Input,args:["sentioResize"]}],duration:[{type:e.Input,args:["sentioDuration"]}],chartReady:[{type:e.Output,args:["sentioChartReady"]}],onResize:[{type:e.HostListener,args:["window:resize",["$event"]]}]},t}(),y=/** @class */function(){function t(){}/** @nocollapse */
return t.forRoot=function(){return{ngModule:t,providers:[]}},t.decorators=[{type:e.NgModule,args:[{exports:[p,h,c,l,d,u,g],declarations:[p,h,c,l,d,u,g]}]}],t.ctorParameters=function(){return[]},t}();t.SentioModule=y,Object.defineProperty(t,"__esModule",{value:!0})});