/*! @asymmetrik/ngx-sentio - 4.6.0 - Copyright Asymmetrik, Ltd. 2007-2017 - All Rights Reserved. + */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("@angular/core"),require("@asymmetrik/sentio"),require("d3"),require("rxjs")):"function"==typeof define&&define.amd?define(["exports","@angular/core","@asymmetrik/sentio","d3","rxjs"],e):e(t.ngxSentio={},t.ng.core,t.sentio,t.d3,t.Rx)}(this,function(t,e,r,i,a){"use strict";/**
 * Wrapper for chart info
 */
var n=/** @class */function(){/**
     * Creates the chart, binds it to the dom element.
     * This doesn't do any DOM manipulation yet.
     * @param el
     * @param chart
     */
function t(t,e,r){this.chartElement=i.select(t.nativeElement),this.chart=e,this.chartReady=r}/**
     * Initializes the chart, creating its DOM structure
     */
return t.prototype.initialize=function(){this.chart.init(this.chartElement),this.chartReady.emit(this.chart)},t}(),s=/** @class */function(){return function(t,e){this.width=t,this.height=e}}(),h=/** @class */function(){function t(t,e,r,n){void 0===e&&(e=!0),void 0===r&&(r=200),void 0===n&&(n=100);var s=this;this.enabled=e,this.chartElement=i.select(t.nativeElement),
// Create a hot observable for resize events
this.resizeSource=a.Observable.create(function(t){s.resizeObserver=t}).publish().refCount().filter(function(){return s.enabled}),null!=r&&(this.resizeSource=this.resizeSource.debounceTime(r)),null!=n&&(this.resizeSource=this.resizeSource.sample(a.Observable.interval(n))),this.resizeSource=this.resizeSource.map(function(){return s.getSize()})}/**
     * Determines the numerical dimension given a string representation
     * Assumes the string is in the form 'NNNNNpx', more specifically
     * an arbitrarily long sequence of digits terminated by 'px'
     *
     * @param dimStr A string representation of the pixel size
     * @returns {number} the numerical representation of the pixel size
     */
/**
     * Returns the size of the element (only returns height/width if they are specified on the DOM elements)
     * Checks attributes and style
     *
     * @param element
     * @returns {ResizeDimension}
     */
/**
     * Returns the size of the element
     * Checks client size
     *
     * @param element
     * @returns {ResizeDimension}
     */
/**
     * Gets the specified dimensions of the element
     * @returns {ResizeDimension}
     */
/**
     * Get the element size (with no overflow)
     * @returns {ResizeDimension}
     */
/**
     * Gets the size of the element (this is the actual size overridden by specified size)
     * Actual size should be based on the size of the parent
     *
     * @returns {ResizeDimension}
     */
return t.parseFloat=function(t,e){var r=parseFloat(t);return isNaN(r)?e:r},t.getPixelDimension=function(t){var e;return null!=t&&""!==t&&(null==(e=parseFloat(t.substring(0,t.length-2)))||isNaN(e))&&(e=void 0),e},t.getSpecifiedSize=function(e){var r=e.attributes.width||t.getPixelDimension(e.style.width),i=e.attributes.height||t.getPixelDimension(e.style.height);return new s(r,i)},t.getActualSize=function(e){var r=getComputedStyle(e),i=t.parseFloat(r.paddingLeft,0)+t.parseFloat(r.paddingRight,0),a=t.parseFloat(r.paddingTop,0)+t.parseFloat(r.paddingBottom,0),n=t.parseFloat(r.borderLeftWidth,0)+t.parseFloat(r.borderRightWidth,0),h=t.parseFloat(r.borderTopWidth,0)+t.parseFloat(r.borderBottomWidth,0),o=e.offsetWidth-i-n,p=e.offsetHeight-a-h;return new s(o,p)},t.prototype.getSpecifiedSize=function(){return t.getSpecifiedSize(this.chartElement.node())},t.prototype.getActualSize=function(){
// Get the raw body element
var e=document.body,r=e.style.overflow;e.style.overflow="hidden";
// The first element child of our selector should be the <div> we injected
var i=this.chartElement.node().parentElement,a=t.getActualSize(i);
// Reapply the old overflow setting
return e.style.overflow=r,a},t.prototype.getSize=function(){var t=this.getSpecifiedSize(),e=this.getActualSize();return null!=t.height&&(e.height=t.height),null!=t.width&&(e.width=t.width),e},t.prototype.destroy=function(){this.resizeObserver.complete()},t}(),o=/** @class */function(){function t(t){
// Chart Ready event
this.chartReady=new e.EventEmitter,
// Create the chart
this.chartWrapper=new n(t,r.chart.donut(),this.chartReady),
// Set up the resizer
this.resizeUtil=new h(t,this.resizeEnabled)}/**
     * For the donut chart, we pin the height to the width
     * to keep the aspect ratio correct
     */
/** @nocollapse */
return t.prototype.setChartDimensions=function(t,e){void 0===e&&(e=!1),(e||this.resizeEnabled)&&null!=t.width&&this.chartWrapper.chart.width()!==t.width&&
// pin the height to the width
this.chartWrapper.chart.width(t.width).height(t.width).resize()},t.prototype.onResize=function(t){this.resizeUtil.resizeObserver.next(t)},t.prototype.ngOnInit=function(){var t=this;
// Initialize the chart
this.chartWrapper.initialize(),
// Set up the resize callback
this.resizeUtil.resizeSource.subscribe(function(){
// Do the resize operation
t.setChartDimensions(t.resizeUtil.getSize()),t.chartWrapper.chart.redraw()}),
// Set the initial size of the chart
this.setChartDimensions(this.resizeUtil.getSize(),!0),this.chartWrapper.chart.redraw()},t.prototype.ngOnDestroy=function(){this.resizeUtil.destroy()},t.prototype.ngOnChanges=function(t){var e=!1,r=!1;t.model&&(this.chartWrapper.chart.data(this.model),r=r||!t.model.isFirstChange()),t.duration&&this.chartWrapper.chart.duration(this.duration),t.colorScale&&(this.chartWrapper.chart.colorScale(this.colorScale),r=r||!t.colorScale.isFirstChange()),t.resize&&(this.resizeUtil.enabled=this.resizeEnabled,e=e||this.resizeEnabled&&!t.resize.isFirstChange(),r=r||e),
// Only redraw once if necessary
e&&this.chartWrapper.chart.resize(),r&&this.chartWrapper.chart.redraw()},t.decorators=[{type:e.Directive,args:[{selector:"sentioDonutChart"}]}],t.ctorParameters=function(){return[{type:e.ElementRef}]},t.propDecorators={model:[{type:e.Input}],colorScale:[{type:e.Input}],resizeEnabled:[{type:e.Input,args:["resize"]}],duration:[{type:e.Input}],chartReady:[{type:e.Output}],onResize:[{type:e.HostListener,args:["window:resize",["$event"]]}]},t}(),p=/** @class */function(){function t(t){
// Chart Ready event
this.chartReady=new e.EventEmitter,
// Create the chart
this.chartWrapper=new n(t,r.chart.matrix(),this.chartReady)}/** @nocollapse */
return t.prototype.ngOnInit=function(){
// Initialize the chart
this.chartWrapper.initialize(),this.chartWrapper.chart.redraw()},t.prototype.ngOnDestroy=function(){},t.prototype.ngOnChanges=function(t){var e=!1;t.model&&(this.chartWrapper.chart.data(this.model),e=e||!t.model.isFirstChange()),t.duration&&this.chartWrapper.chart.duration(this.duration),
// Only redraw once if possible
e&&this.chartWrapper.chart.redraw()},t.decorators=[{type:e.Directive,args:[{selector:"sentioMatrixChart"}]}],t.ctorParameters=function(){return[{type:e.ElementRef}]},t.propDecorators={model:[{type:e.Input}],duration:[{type:e.Input}],chartReady:[{type:e.Output}]},t}(),c=/** @class */function(){/**
     * Creates the chart, binds it to the dom element.
     * This doesn't do any DOM manipulation yet.
     * @param el
     * @param chart
     */
function t(t){this.chartWrapper=t}return t.prototype.setChartDimensions=function(t,e,r,i){void 0===i&&(i=!1);var a=!1;(i||e)&&null!=t.width&&this.chartWrapper.chart.width()!==t.width&&(
// pin the height to the width
this.chartWrapper.chart.width(t.width),a=!0),(i||r)&&null!=t.height&&this.chartWrapper.chart.height()!==t.height&&(
// pin the height to the width
this.chartWrapper.chart.height(t.height),a=!0),a&&this.chartWrapper.chart.resize()},t}(),u=/** @class */function(){function t(t){
// Chart Ready event
this.chartReady=new e.EventEmitter,
// Interaction events
this.markerOver=new e.EventEmitter,this.markerOut=new e.EventEmitter,this.markerClick=new e.EventEmitter,
// Create the chart
this.chartWrapper=new n(t,r.chart.realtimeTimeline(),this.chartReady),
// Set up the resizer
this.resizeUtil=new h(t,this.resizeHeight||this.resizeWidth),this.timelineUtil=new c(this.chartWrapper)}/** @nocollapse */
return t.prototype.onResize=function(t){this.resizeUtil.resizeObserver.next(t)},t.prototype.ngOnInit=function(){var t=this;
// Initialize the chart
this.chartWrapper.initialize(),
// register for the marker events
this.chartWrapper.chart.dispatch().on("markerClick",function(e){t.markerClick.emit(e)}),this.chartWrapper.chart.dispatch().on("markerMouseover",function(e){t.markerOver.emit(e)}),this.chartWrapper.chart.dispatch().on("markerMouseout",function(e){t.markerOut.emit(e)}),
// Set up the resize callback
this.resizeUtil.resizeSource.subscribe(function(){
// Do the resize operation
t.timelineUtil.setChartDimensions(t.resizeUtil.getSize(),t.resizeWidth,t.resizeHeight),t.chartWrapper.chart.redraw()}),
// Set the initial size of the chart
this.timelineUtil.setChartDimensions(this.resizeUtil.getSize(),this.resizeWidth,this.resizeHeight,!0),this.chartWrapper.chart.redraw()},t.prototype.ngOnDestroy=function(){this.resizeUtil.destroy()},t.prototype.ngOnChanges=function(t){var e=!1;t.model&&(this.chartWrapper.chart.data(this.model),e=e||!t.model.isFirstChange()),t.markers&&(this.chartWrapper.chart.markers(this.markers),e=e||!t.markers.isFirstChange()),t.yExtent&&(this.chartWrapper.chart.yExtent().overrideValue(this.yExtent),e=e||!t.yExtent.isFirstChange()),t.xExtent&&(this.chartWrapper.chart.xExtent().overrideValue(this.xExtent),e=e||!t.xExtent.isFirstChange()),t.fps&&this.chartWrapper.chart.fps(this.fps),t.delay&&(this.chartWrapper.chart.delay(this.delay),e=e||!t.delay.isFirstChange()),t.interval&&(this.chartWrapper.chart.interval(this.interval),e=e||!t.interval.isFirstChange()),e&&this.chartWrapper.chart.redraw()},t.decorators=[{type:e.Directive,args:[{selector:"sentioRealtimeTimeline"}]}],t.ctorParameters=function(){return[{type:e.ElementRef}]},t.propDecorators={model:[{type:e.Input}],markers:[{type:e.Input}],yExtent:[{type:e.Input}],xExtent:[{type:e.Input}],delay:[{type:e.Input}],fps:[{type:e.Input}],interval:[{type:e.Input}],resizeWidth:[{type:e.Input}],resizeHeight:[{type:e.Input}],chartReady:[{type:e.Output}],markerOver:[{type:e.Output}],markerOut:[{type:e.Output}],markerClick:[{type:e.Output}],onResize:[{type:e.HostListener,args:["window:resize",["$event"]]}]},t}(),l=/** @class */function(){function t(t){
// Chart Ready event
this.chartReady=new e.EventEmitter,this.filterChange=new e.EventEmitter,
// Interaction events
this.markerOver=new e.EventEmitter,this.markerOut=new e.EventEmitter,this.markerClick=new e.EventEmitter,/**
         * Did the state of the filter change?
         */
this.didFilterChange=function(t,e){
// Deep compare the filter
return t!==e&&(null==t||null==e||t[0]!==e[0]||t[1]!==e[1])},
// Create the chart
this.chartWrapper=new n(t,r.chart.timeline(),this.chartReady),
// Set up the resizer
this.resizeUtil=new h(t,this.resizeHeight||this.resizeWidth),this.timelineUtil=new c(this.chartWrapper)}/** @nocollapse */
return t.prototype.onResize=function(t){this.resizeUtil.resizeObserver.next(t)},t.prototype.ngOnInit=function(){var t=this;
// Initialize the chart
this.chartWrapper.initialize(),
// register for the marker events
this.chartWrapper.chart.dispatch().on("markerClick",function(e){t.markerClick.emit(e)}),this.chartWrapper.chart.dispatch().on("markerMouseover",function(e){t.markerOver.emit(e)}),this.chartWrapper.chart.dispatch().on("markerMouseout",function(e){t.markerOut.emit(e)}),
// register for the filter end event
this.chartWrapper.chart.dispatch().on("filterend",function(e){
// If the filter actually changed, emit the event
t.didFilterChange(e,t.filterState)&&setTimeout(function(){t.filterChange.emit(e)})}),
// Set up the resize callback
this.resizeUtil.resizeSource.subscribe(function(){
// Do the resize operation
t.timelineUtil.setChartDimensions(t.resizeUtil.getSize(),t.resizeWidth,t.resizeHeight),t.chartWrapper.chart.redraw()}),
// Set the initial size of the chart
this.timelineUtil.setChartDimensions(this.resizeUtil.getSize(),this.resizeWidth,this.resizeHeight,!0),this.chartWrapper.chart.redraw(),
// Set the filter (if it exists)
null!=this.filterState&&this.chartWrapper.chart.setFilter(this.filterState)},t.prototype.ngOnDestroy=function(){this.resizeUtil.destroy()},t.prototype.ngOnChanges=function(t){var e=!1;t.model&&(this.chartWrapper.chart.data(this.model),e=e||!t.model.isFirstChange()),t.markers&&(this.chartWrapper.chart.markers(this.markers),e=e||!t.markers.isFirstChange()),t.yExtent&&(this.chartWrapper.chart.yExtent().overrideValue(this.yExtent),e=e||!t.yExtent.isFirstChange()),t.xExtent&&(this.chartWrapper.chart.xExtent().overrideValue(this.xExtent),e=e||!t.xExtent.isFirstChange()),t.filterEnabled&&(this.chartWrapper.chart.filter(this.filterEnabled),e=e||!t.filterEnabled.isFirstChange()),t.filterState&&!t.filterState.isFirstChange()&&this.didFilterChange(t.filterState.currentValue,t.filterState.previousValue)&&(this.chartWrapper.chart.setFilter(this.filterState),e=!0),e&&this.chartWrapper.chart.redraw()},t.decorators=[{type:e.Directive,args:[{selector:"sentioTimeline"}]}],t.ctorParameters=function(){return[{type:e.ElementRef}]},t.propDecorators={model:[{type:e.Input}],markers:[{type:e.Input}],yExtent:[{type:e.Input}],xExtent:[{type:e.Input}],resizeWidth:[{type:e.Input}],resizeHeight:[{type:e.Input}],chartReady:[{type:e.Output}],filterEnabled:[{type:e.Input}],filterState:[{type:e.Input,args:["filter"]}],filterChange:[{type:e.Output}],markerOver:[{type:e.Output}],markerOut:[{type:e.Output}],markerClick:[{type:e.Output}],onResize:[{type:e.HostListener,args:["window:resize",["$event"]]}]},t}(),d=/** @class */function(){function t(t){
// Chart Ready event
this.chartReady=new e.EventEmitter,
// Create the chart
this.chartWrapper=new n(t,r.chart.verticalBars(),this.chartReady),
// Set up the resizer
this.resizeUtil=new h(t,this.resizeEnabled)}/**
     * For The vertical bar chart, we just resize width
     */
/** @nocollapse */
return t.prototype.setChartDimensions=function(t,e){void 0===e&&(e=!1),(e||this.resizeEnabled)&&null!=t.width&&this.chartWrapper.chart.width()!==t.width&&
// pin the height to the width
this.chartWrapper.chart.width(t.width).resize()},t.prototype.onResize=function(t){this.resizeUtil.resizeObserver.next(t)},t.prototype.ngOnInit=function(){var t=this;
// Initialize the chart
this.chartWrapper.initialize(),
// Set up the resize callback
this.resizeUtil.resizeSource.subscribe(function(){
// Do the resize operation
t.setChartDimensions(t.resizeUtil.getSize()),t.chartWrapper.chart.redraw()}),
// Set the initial size of the chart
this.setChartDimensions(this.resizeUtil.getSize(),!0),this.chartWrapper.chart.redraw()},t.prototype.ngOnDestroy=function(){this.resizeUtil.destroy()},t.prototype.ngOnChanges=function(t){var e=!1,r=!1;t.model&&(this.chartWrapper.chart.data(this.model),r=r||!t.model.isFirstChange()),t.widthExtent&&(this.chartWrapper.chart.widthExtent().overrideValue(this.widthExtent),r=r||!t.widthExtent.isFirstChange()),t.resize&&(this.resizeUtil.enabled=this.resizeEnabled,e=e||this.resizeEnabled&&!t.resize.isFirstChange(),r=r||e),
// Only redraw once if necessary
e&&this.chartWrapper.chart.resize(),r&&this.chartWrapper.chart.redraw()},t.decorators=[{type:e.Directive,args:[{selector:"sentioVerticalBarChart"}]}],t.ctorParameters=function(){return[{type:e.ElementRef}]},t.propDecorators={model:[{type:e.Input}],widthExtent:[{type:e.Input}],resizeEnabled:[{type:e.Input,args:["resize"]}],duration:[{type:e.Input}],chartReady:[{type:e.Output}],onResize:[{type:e.HostListener,args:["window:resize",["$event"]]}]},t}(),y=/** @class */function(){function t(){}/** @nocollapse */
return t.forRoot=function(){return{ngModule:t,providers:[]}},t.decorators=[{type:e.NgModule,args:[{exports:[o,p,u,l,d],declarations:[o,p,u,l,d]}]}],t.ctorParameters=function(){return[]},t}();t.SentioModule=y,Object.defineProperty(t,"__esModule",{value:!0})});